# Common Mistakes: Evaluate Reverse Polish Notation

## Problem Overview
Evaluate an arithmetic expression given in **Reverse Polish Notation (RPN)**.

**Key Requirements:**
- Valid operators: `'+'`, `'-'`, `'*'`, `'/'`
- Division truncates **toward zero** (not floor division!)
- Return an **integer** result

**Example:** `["4","13","5","/","+"]`
- `13 / 5 = 2` (truncate toward zero)
- `4 + 2 = 6`
- Result: `6`

---

## ‚ùå Incorrect Solution

```python
from operator import add, sub, mul

def div(x, y): 
    return x/y if x*y > 0 else -(abs(x) // abs(y))

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        op_map = {'+': add, '-': sub, '*': mul, '/': div}
        stack = []
        for token in tokens:
            if token not in {'+', '-', '*', '/'}:
                stack.append(int(token))
            else:
                op1 = stack.pop()
                op2 = stack.pop()
                stack.append(op_map[token](op1, op2))
        return stack.pop()
```

**Test Case:**
```
Input: ["4","13","5","/","+"]
Output: 4.384615384615385  ‚ùå
Expected: 6
```

---

## üêõ Mistakes Identified

### 1. **Division Returns Float Instead of Integer**

```python
def div(x, y): 
    return x/y if x*y > 0 else -(abs(x) // abs(y))
    #      ^^^ Returns FLOAT when x*y > 0!
```

**Problem:** 
- When both operands have the same sign, `x/y` returns a **float**
- The problem requires an **integer** result
- This causes all subsequent calculations to use floats

**Example:**
```python
div(13, 5)  # x*y = 65 > 0
# Returns: 2.6  ‚ùå (should be 2)
```

**Fix:** Add `int()` to truncate toward zero
```python
return int(x/y) if x*y > 0 else -(abs(x) // abs(y))
#      ^^^
```

---

### 2. **Wrong Operand Order (Subtle but Critical!)**

```python
op1 = stack.pop()  # Gets 5 (last pushed)
op2 = stack.pop()  # Gets 13 (pushed before 5)
stack.append(op_map[token](op1, op2))  # Computes: 5 / 13 ‚ùå
```

**Problem:** In RPN, operators work on operands in the order they were pushed!

**Understanding Stack Order:**
```
Stack visualization for ["4","13","5","/"]

After pushing all numbers:
‚îå‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5 ‚îÇ ‚Üê Top (popped FIRST as op1)
‚îú‚îÄ‚îÄ‚îÄ‚î§
‚îÇ13 ‚îÇ ‚Üê Popped SECOND as op2
‚îú‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 4 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îò

But we want: 13 / 5, not 5 / 13!
```

**Why This Matters:**
- For `+` and `*`: Order doesn't matter (commutative)
  - `5 + 13 = 13 + 5` ‚úÖ
  - `5 * 13 = 13 * 5` ‚úÖ
- For `-` and `/`: **Order is critical!** (non-commutative)
  - `5 - 13 = -8` but `13 - 5 = 8` ‚ùå
  - `5 / 13 = 0.38...` but `13 / 5 = 2.6` ‚ùå

**The Trace Through:**
```
tokens = ["4","13","5","/","+"]

Step 1-3: Push numbers
stack = [4, 13, 5]

Step 4: Process '/'
op1 = stack.pop()  ‚Üí op1 = 5
op2 = stack.pop()  ‚Üí op2 = 13
result = op_map['/'](op1, op2)  ‚Üí 5 / 13 = 0.384... ‚ùå
stack = [4, 0.384...]

Step 5: Process '+'
op1 = stack.pop()  ‚Üí op1 = 0.384...
op2 = stack.pop()  ‚Üí op2 = 4
result = op_map['+'](op1, op2)  ‚Üí 0.384... + 4 = 4.384... ‚ùå

Output: 4.384615384615385 ‚ùå
Expected: 6
```

**Fix:** Swap the variable names to match the correct order
```python
op2 = stack.pop()  # Second operand (right side)
op1 = stack.pop()  # First operand (left side)
stack.append(op_map[token](op1, op2))  # Now: op1 / op2 = 13 / 5 ‚úÖ
```

---

## ‚úÖ Correct Solution

```python
from operator import add, sub, mul

def div(x, y): 
    return int(x / y) if x * y > 0 else -(abs(x) // abs(y))
    #      ^^^^ Truncate toward zero

class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        op_map = {'+': add, '-': sub, '*': mul, '/': div}
        stack = []
        
        for token in tokens:
            if token not in {'+', '-', '*', '/'}:
                stack.append(int(token))
            else:
                op2 = stack.pop()  # Second operand (right side)
                op1 = stack.pop()  # First operand (left side)
                stack.append(op_map[token](op1, op2))
        
        return stack.pop()
```

---

## üîç Correct Trace Through

**Input:** `["4","13","5","/","+"]`

| Step | Token | Action | Stack | Explanation |
|------|-------|--------|-------|-------------|
| 1 | "4" | Push | [4] | Push operand |
| 2 | "13" | Push | [4, 13] | Push operand |
| 3 | "5" | Push | [4, 13, 5] | Push operand |
| 4 | "/" | Operate | [4, 2] | Pop 5 (op2), pop 13 (op1) ‚Üí 13/5=2 |
| 5 | "+" | Operate | [6] | Pop 2 (op2), pop 4 (op1) ‚Üí 4+2=6 |
| 6 | - | Return | - | Pop and return 6 |

**Result:** `6` ‚úÖ

---

## üí° Key Takeaways

### 1. **Always Return Correct Data Types**
- If problem asks for `int`, ensure all operations return `int`
- Python's `/` always returns `float`, even for `10 / 2 = 5.0`
- Use `int()` to convert when needed

### 2. **Stack Operand Order Matters!**
- **First pop** = **second operand** (right side of operation)
- **Second pop** = **first operand** (left side of operation)
- Critical for non-commutative operations (`-`, `/`, `**`, etc.)

### 3. **Truncate Toward Zero vs Floor Division**
```python
# Python's // floors toward negative infinity
-7 // 2 = -4  ‚ùå

# int() truncates toward zero (what we need!)
int(-7 / 2) = int(-3.5) = -3  ‚úÖ
```

### 4. **Variable Naming Clarity**
Using clear variable names helps avoid confusion:
```python
# Good naming that shows order
right = stack.pop()   # Second operand
left = stack.pop()    # First operand
result = left - right # Clear: left - right

# Or
op2 = stack.pop()     # Pops first, but is second operand
op1 = stack.pop()     # Pops second, but is first operand
result = op1 - op2    # op1 is on the left
```

---

## üéØ Common Pitfalls Summary

| Mistake | Symptom | Fix |
|---------|---------|-----|
| Using `x/y` without `int()` | Float results instead of integers | Use `int(x/y)` |
| Wrong operand order | Wrong results for `-` and `/` | Pop op2 first, then op1 |
| Using `//` for division | Wrong results with negatives | Use `int(x/y)` or custom div |
| Testing only with `+` and `*` | Bugs hidden (commutative ops) | Always test with `-` and `/` |

---

## üìö Related Concepts

- **Reverse Polish Notation (RPN)** - Postfix notation, no parentheses needed
- **Stack data structure** - LIFO, perfect for RPN evaluation
- **Operator precedence** - Not needed in RPN!
- **Truncation vs Floor division** - Different behaviors with negatives
- **Commutative vs Non-commutative operations** - Order matters for some operators
