# Sliding Window Maximum - Solution Summary

## Problem Overview
Given an array of integers and a window size `k`, find the maximum value in each sliding window as it moves from left to right across the array.

**Example:**
- Input: `nums = [1,3,-1,-3,5,3,6,7]`, `k = 3`
- Output: `[3,3,5,5,6,7]`

## Solution Approach: Monotonic Deque

### Key Idea
Use a **deque (double-ended queue)** to maintain potential maximum values in decreasing order. This allows O(1) access to the current window's maximum.

### Algorithm Steps

1. **Maintain decreasing deque**: For each new element, remove all smaller elements from the back of the deque (they can never be the maximum)
2. **Add new element**: Append the current element to the deque
3. **Remove outdated elements**: If the front element is outside the current window, remove it
4. **Record maximum**: Once the window reaches size `k`, the front of the deque is the maximum

### Code Structure

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        max_list = []
        kept_nums = deque()
        
        for i in range(len(nums)):
            # Add new element while maintaining decreasing order
            updateElem(kept_nums, nums[i])
            
            # Remove element that's outside the window
            if i >= k and nums[i-k] == kept_nums[0]:
                kept_nums.popleft()
            
            # Start recording maximums once window is full
            if i >= k - 1:
                max_list.append(kept_nums[0])
                
        return max_list

def updateElem(kept_nums, num):
    # Remove all smaller elements from the back
    while kept_nums and num > kept_nums[-1]:
        kept_nums.pop()
    kept_nums.append(num)
```

## Common Mistake: Window Boundary Condition

### âŒ The Mistake
Using `if i >= k:` instead of `if i >= k - 1:` when appending to results.

### Why This Is Wrong
- **Window indices**: For a window of size `k`, the first complete window ends at index `k-1` (indices `0` through `k-1`)
- Using `i >= k` would skip the first valid window and start recording from index `k` instead

### ðŸ“Š Example Walkthrough
For `nums = [1, 3, -1, -3, 5]` with `k = 3`:

| Index i | Window Elements | Should Append? | `i >= k-1` | `i >= k` |
|---------|----------------|----------------|-----------|----------|
| 0       | [1]            | No (incomplete)| False     | False    |
| 1       | [1, 3]         | No (incomplete)| False     | False    |
| **2**   | **[1, 3, -1]** | **Yes** âœ“      | **True**  | False âŒ |
| 3       | [3, -1, -3]    | Yes âœ“          | True      | True     |
| 4       | [-1, -3, 5]    | Yes âœ“          | True      | True     |

Using `i >= k` would **miss the first valid window** at index 2!

### âœ… Correct Condition
```python
if i >= k - 1:  # First complete window is at index k-1
    max_list.append(kept_nums[0])
```

## Complexity Analysis
- **Time Complexity**: O(n) - Each element is added and removed from deque at most once
- **Space Complexity**: O(k) - Deque stores at most k elements

## Key Takeaways
1. The **first complete window** of size `k` ends at index `k-1`, not `k`
2. Always consider **zero-based indexing** when dealing with window positions
3. The condition `i >= k-1` ensures we start recording from the first complete window
