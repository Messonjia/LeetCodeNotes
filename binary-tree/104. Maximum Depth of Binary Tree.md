# 104. Maximum Depth of Binary Tree

## Problem Statement

Given the root of a binary tree, return its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

## Solution Approach

This solution uses a **recursive depth-first search (DFS)** approach with postorder traversal (left-right-root).

### Algorithm

1. **Base Case**: If the current node is `None`, return depth of 0
2. **Recursive Case**: 
   - Recursively calculate the depth of the left subtree
   - Recursively calculate the depth of the right subtree
   - Return 1 (current node) + maximum of left and right depths

### Code Implementation

```python
class Solution:
    def maxdepth(self, root: TreeNode) -> int:
        return self.getdepth(root)
        
    def getdepth(self, node):
        if not node:
            return 0
        leftheight = self.getdepth(node.left)    # Left
        rightheight = self.getdepth(node.right)  # Right
        height = 1 + max(leftheight, rightheight) # Root
        return height
```

## Complexity Analysis

- **Time Complexity**: O(n)
  - We visit each node exactly once, where n is the number of nodes in the tree

- **Space Complexity**: O(h)
  - The space is used by the recursion call stack
  - In the worst case (skewed tree), h = n
  - In the best case (balanced tree), h = log(n)

## Example Walkthrough

Consider the tree:
```
    3
   / \
  9  20
     / \
    15  7
```

Execution flow:
1. Start at root (3)
2. Recurse left to node 9 (leaf): returns 1
3. Recurse right to node 20
   - Left child 15 (leaf): returns 1
   - Right child 7 (leaf): returns 1
   - Node 20 returns: 1 + max(1, 1) = 2
4. Root returns: 1 + max(1, 2) = **3**

## Alternative Approach

The solution can be simplified to a one-liner:

```python
def maxdepth(self, root: TreeNode) -> int:
    if not root:
        return 0
    return 1 + max(self.maxdepth(root.left), self.maxdepth(root.right))
```

## Key Insights

- This is a classic example of **postorder traversal** (process children before parent)
- The pattern of checking left, then right, then processing the current node is fundamental to many tree problems
- The recursive approach naturally handles the tree structure by breaking it down into subproblems
