# 226. Invert Binary Tree

## Problem Statement

Given the `root` of a binary tree, invert the tree, and return its root.

**Example:**

Input:
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

Output:
```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

## Recursive Solution

```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```

## How It Works

### Key Idea
The solution uses **recursion** to swap the left and right children at every node, working from top to bottom.

### Step-by-Step Breakdown

1. **Base Case**: If the node is `None`, return `None` (we've reached the end of a branch)

2. **Swap Children**: At the current node, swap the left and right children
   ```python
   root.left, root.right = root.right, root.left
   ```

3. **Recurse**: Recursively invert the left and right subtrees
   ```python
   self.invertTree(root.left)
   self.invertTree(root.right)
   ```

4. **Return**: Return the root node (now inverted)

## Execution Trace

Let's trace through the example tree:

```
Original:
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

### Call Stack Visualization

```
invertTree(4):
  - Swap: left=7, right=2
  - invertTree(7):  # Note: 7 is now on the left
      - Swap: left=9, right=6
      - invertTree(9):
          - No children, return 9
      - invertTree(6):
          - No children, return 6
      - return 7
  - invertTree(2):  # Note: 2 is now on the right
      - Swap: left=3, right=1
      - invertTree(3):
          - No children, return 3
      - invertTree(1):
          - No children, return 1
      - return 2
  - return 4
```

### Result:
```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

## Why This Works

1. **Swap at each level**: By swapping left and right at every node, we mirror the tree structure
2. **Recursion handles depth**: The recursive calls ensure we reach every node in the tree
3. **Bottom-up processing**: Even though we swap before recursing, the recursion naturally processes from leaves upward

## Important Note on Swap Timing

Notice that we swap **before** recursing. This is important:

```python
# Swap first
root.left, root.right = root.right, root.left

# Then recurse on the NEW positions
self.invertTree(root.left)   # This is the original right child
self.invertTree(root.right)  # This is the original left child
```

After the swap, `root.left` points to what was originally the right subtree, and vice versa. The recursion then inverts those swapped subtrees.

## Complexity Analysis

- **Time Complexity**: O(n) - we visit each node exactly once
- **Space Complexity**: O(h) - where h is the height of the tree
  - This is the space used by the recursion call stack
  - Worst case: O(n) for a skewed tree
  - Best case: O(log n) for a balanced tree

## Alternative Approach: Iterative with Queue

While recursion is elegant, you can also solve this iteratively using a queue (BFS):

```python
def invertTree(self, root: TreeNode) -> TreeNode:
    if not root:
        return None
    
    queue = collections.deque([root])
    
    while queue:
        node = queue.popleft()
        # Swap children
        node.left, node.right = node.right, node.left
        
        # Add children to queue
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    return root
```

This has the same time complexity but uses O(w) space where w is the maximum width of the tree.

## Key Takeaways

- Simple recursive solution with just 3 operations: base case, swap, recurse
- Python's tuple unpacking makes the swap elegant: `a, b = b, a`
- Remember to swap **before** recursing
- This is a classic example of how recursion can simplify tree problems
