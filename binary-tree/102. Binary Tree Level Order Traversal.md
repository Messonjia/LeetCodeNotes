# Binary Tree Level Order Traversal

## Problem Statement

Given the `root` of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).

## Solution

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        queue = collections.deque([root])
        result = []
        while queue:
            level = []
            for _ in range(len(queue)):
                cur = queue.popleft()
                level.append(cur.val)
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            result.append(level)
        return result
```

## Key Concept: Understanding `len(queue)`

The most important insight is that **`len(queue)` is calculated ONCE at the start of each level**, before the for loop begins.

This allows us to:
- Know exactly how many nodes are at the current level
- Process only those nodes, even as we add their children to the queue
- Separate nodes by level

## Step-by-Step Example

Given this tree:
```
        1
       / \
      2   3
     / \
    4   5
```

### Level 1 Processing
- Initial: `queue = [1]`, `len(queue) = 1`
- `for _ in range(1):` → loop runs **1 time**
- Pop node `1`, add to level
- Add children `2` and `3` to queue
- Queue becomes `[2, 3]`, but for loop already finished
- Result: `level = [1]`

### Level 2 Processing
- Start: `queue = [2, 3]`, `len(queue) = 2`
- `for _ in range(2):` → loop runs **2 times**
- Iteration 1: Pop node `2`, add children `4` and `5`
- Iteration 2: Pop node `3` (no children)
- Queue becomes `[4, 5]`
- Result: `level = [2, 3]`

### Level 3 Processing
- Start: `queue = [4, 5]`, `len(queue) = 2`
- `for _ in range(2):` → loop runs **2 times**
- Process nodes `4` and `5`
- Result: `level = [4, 5]`

### Final Result
```python
[[1], [2, 3], [4, 5]]
```

## Why This Works

1. **Queue captures level boundaries**: At the start of each while loop, the queue contains exactly the nodes from one level
2. **For loop processes exactly one level**: By using `len(queue)` before the loop starts, we process exactly that many nodes
3. **Children go to next level**: New nodes added during the for loop stay in the queue for the next while loop iteration

## Example with Different Tree Sizes

If the third layer has 4 nodes:
```
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

- Level 3: `queue = [4, 5, 6, 7]`, `len(queue) = 4`
- `for _ in range(4):` → loop runs **4 times**
- Result: `level = [4, 5, 6, 7]`

## Time and Space Complexity

- **Time Complexity**: O(n) - we visit each node exactly once
- **Space Complexity**: O(n) - in the worst case (complete binary tree), the queue can hold up to n/2 nodes at the last level
