# Binary Tree Traversal - Learning Summary

## Key Concepts Learned

### Chinese Programming Terms
- **堆 (duī)** = Heap (data structure or memory region)
- **满二叉树 (mǎn èr chā shù)** = Perfect/Full Binary Tree
- **完全二叉树 (wán quán èr chā shù)** = Complete Binary Tree
- **前序遍历** = Preorder Traversal
- **中序遍历** = Inorder Traversal  
- **后序遍历** = Postorder Traversal
- **层序遍历** = Level-order Traversal (BFS)

### Complete vs Perfect Binary Trees
- **Perfect Binary Tree (满二叉树)**: All levels completely filled, all leaves at same depth
- **Complete Binary Tree (完全二叉树)**: All levels filled except possibly the last, which fills left-to-right
- **Important**: Heaps use complete binary trees, but not all complete binary trees are heaps

## Common Misconceptions Clarified

### Misconception 1: "Pre, In, Post" naming is arbitrary
**Reality**: The names indicate **when the root node is processed** relative to its children:
- **Preorder**: Process root **BEFORE** children (Root → Left → Right)
- **Inorder**: Process root **IN BETWEEN** children (Left → Root → Right)  
- **Postorder**: Process root **AFTER** children (Left → Right → Root)

### Misconception 2: Pre/In/Post are different from DFS
**Reality**: All three traversals ARE types of DFS! They all:
- Go deep into branches before exploring others
- Use recursion or a stack
- Only differ in **when** they process the current node

The key difference is DFS vs BFS:
- **DFS** (Pre/In/Post): Uses stack/recursion, goes deep first
- **BFS** (Level-order): Uses queue, visits level by level

### Misconception 3: Practical uses are random
**Reality**: Each traversal matches its use case's **dependency order**:

| Traversal | Use Case | Why It Works |
|-----------|----------|--------------|
| **Preorder** | Copy tree, prefix expressions | Need parent before children (create root first, then attach children) |
| **Inorder** | Get sorted order from BST | Left < Root < Right gives natural ascending order |
| **Postorder** | Delete tree, postfix expressions | Need children before parent (free children first to avoid losing pointers) |

### Misconception 4: LeetCode array input is what you work with
**Reality**: 
- Array notation like `[1,null,2,3]` is just for **test case representation**
- LeetCode converts this to actual **TreeNode objects** behind the scenes
- You work with objects using `.left` and `.right` pointers, not arrays
- The array uses level-order (BFS) indexing to represent the tree structure

## Tree Traversal Quick Reference

### DFS Traversals (using stack/recursion)
```
Example tree:
     1
    / \
   2   3
  / \
 4   5

Preorder:  1, 2, 4, 5, 3  (Root first)
Inorder:   4, 2, 5, 1, 3  (Root in middle)
Postorder: 4, 5, 2, 3, 1  (Root last)
```

### BFS Traversal (using queue)
```
Level-order: 1, 2, 3, 4, 5  (Level by level)
```

## TreeNode Structure
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val      # Node value
        self.left = left    # Pointer to left child TreeNode
        self.right = right  # Pointer to right child TreeNode
```

Each node is an object containing:
- A value
- A reference to left child (TreeNode or None)
- A reference to right child (TreeNode or None)

## Related LeetCode Problems
- **LC 144**: Binary Tree Preorder Traversal
- **LC 94**: Binary Tree Inorder Traversal (typically mentioned alongside 144)
- **LC 145**: Binary Tree Postorder Traversal
- **LC 102**: Binary Tree Level Order Traversal (BFS)

All three DFS traversals can be solved with the same recursive pattern, just changing when you process the current node!
