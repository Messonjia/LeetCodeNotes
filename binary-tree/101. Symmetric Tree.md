# Symmetric Tree Solution

## Problem
Check if a binary tree is symmetric (mirror image of itself around its center).

## Approach
Use **recursive comparison** of the tree's left and right subtrees.

## Key Ideas

### 1. Base Cases
- Empty tree is symmetric
- Compare left and right subtrees of the root

### 2. Recursive Comparison
For two nodes to be mirrors of each other:
- **Both are None**: symmetric ✓
- **One is None, other isn't**: not symmetric ✗
- **Both exist but values differ**: not symmetric ✗
- **Both exist with same values**: recursively check:
  - **Outside pair**: `left.left` vs `right.right`
  - **Inside pair**: `left.right` vs `right.left`

### 3. Symmetry Condition
The tree is symmetric if **both** the outside and inside pairs are symmetric.

## Algorithm
```
isSymmetric(root):
    if root is None: return True
    return compare(root.left, root.right)

compare(left, right):
    if both None: return True
    if only one None: return False
    if values differ: return False
    
    return compare(left.left, right.right) AND 
           compare(left.right, right.left)
```

## Implementation
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        return self.compare(root.left, root.right)

    def compare(self, left, right):
        if left == None and right != None:
            return False
        if left != None and right == None:
            return False
        if left == None and right == None:
            return True
        
        if left.val != right.val:
            return False

        outside = self.compare(left.left, right.right)
        inside = self.compare(left.right, right.left)
        isSame = outside and inside
        return isSame
```

## Complexity
- **Time**: O(n) - visit each node once
- **Space**: O(h) - recursion stack depth (h = height of tree)

## Example
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```
Symmetric: left subtree `(2,3,4)` mirrors right subtree `(2,4,3)` ✓

```
    1
   / \
  2   2
   \   \
    3   3
```
Not symmetric: left has right child, right has right child (should be left) ✗
